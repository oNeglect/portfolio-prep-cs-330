// Lawrence Arundel CS 330 7-1 Submit Project
// Sources: 
// Amazon, A. (2021, January 1). Amazon.com: InterestPrint Geometric Triangle Foldable Eyeglass Case Triangular Sunglasses Case Hard Shell, from https://www.amazon.com/InterestPrint-Geometric-Triangle-Triangular-Sunglasses/dp/B07V3SQBMQ
// Bubnar, M. (2009, January 29). Going 3D With Transformations. 04.) going 3D with transformations - opengl 3 - tutorials - megabyte softworks., from https://www.mbsoftworks.sk/tutorials/opengl3/04-going-3d-with-transformations/ 
// Chapman, S. (2020, November 20). Snhu-CS/CS-330. GitHub., from https://github.com/SNHU-CS/CS-330 
// Chapman, S. (2020, November 20). CS-330/mod2_tutorials.MD at master · Snhu-CS/CS-330. GitHub., from https://github.com/SNHU-CS/CS-330/blob/master/module02/mod2_tutorials.md 
// cppreference, cppreference. (2022, October 1). Algorithms library. cppreference.com., from https://en.cppreference.com/w/cpp/algorithm 
// Datenwolf, D. (2013, November 10). Licence file adjusted · Datenwolf/Linmath.h@53e98e2. GitHub., from https://github.com/datenwolf/linmath.h/commit/53e98e22b0744aafd31b32002633b308c9d2a179# 	
// Dias, D. (2021, June 28). Why "using namespace std" is used after including iostream. Medium., from https://medium.com/breaktheloop/why-using-namespace-std-is-used-after-including-iostream-dc5ae45db652#:~:text=%E2%80%9Cusing%20namespace%20std%E2%80%9D%20means%20we,%3A%3Acout%2C%20std%3A%3Aendl. 
// Disqus, D. (2014, January 1). Coordinate systems. LearnOpenGL., from https://learnopengl.com/Getting-Started/Coordinate-Systems#:~:text=An%20orthographic%20projection%20matrix%20defines,length%20of%20the%20visible%20frustum. 
// Doxygen, D. (2020, January 1). OpenGL Mathematics., from https://glm.g-truc.net/0.9.2/api/a00001.html 
// Exterman, D. (2021, September 28). Cstdlib in C++ - explained. Incredibuild., from https://www.incredibuild.com/blog/cstdlib-in-c-explained#:~:text=What%20Is%20cstdlib%20in%20C,code%20across%20teams%20and%20platforms. 
// GeeksforGeeks, G. G. (2022, December 11). Basic input / output in C++. GeeksforGeeks., from https://www.geeksforgeeks.org/basic-input-output-c/ 
// GeeksforGeeks, G. G. (2022, December 11). Basic input / output in C++. GeeksforGeeks., from https://www.geeksforgeeks.org/stdstring-class-in-c/
// GeeksforGeeks, G. G. (2022, December 11). Basic input / output in C++. GeeksforGeeks., from https://www.geeksforgeeks.org/vector-in-cpp-stl/
// GeeksforGeeks, G. G. (2022, July 2). Basic input / output in C++. GeeksforGeeks., from https://www.geeksforgeeks.org/stringstream-c-applications/
// GitBook, G. B. (2020, January 1). Understanding coordinate transformations. Understanding Coordinate Transformations · LegacyOpenGL., from https://gdbooks.gitbooks.io/legacyopengl/content/Chapter4/CoordinateTransforms.html 
// GLFW, G. L. F. W. (2018, November 4). Including the GLFW header file. GLFW., from https://www.glfw.org/docs/3.0/build.html 
// Graphics, S. (2006, January 1). glViewPort. Glviewport - OpenGL 4 reference pages., from https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewport.xhtml 
// IBM, I. B. M. (2021, April 8). The #ifndef directive. The #IFNDEF directive., from https://www.ibm.com/docs/en/zos/2.4.0?topic=directives-ifndef-directive 
// IBM, I. B. M. (2021, April 8). The #ifndef directive. The #IFNDEF directive., from https://www.ibm.com/docs/en/zos/2.3.0?topic=expressions-static-cast-operator-c-only
// IBM, I. B. M. (2021, April 8). The #ifndef directive. The #IFNDEF directive., from https://www.ibm.com/docs/en/zos/2.3.0?topic=directives-ifndef-directive
// Khronos, K. (1999, June 1). Name glGenerateMipmap, glGenerateTextureMipmap — generate mipmaps for a specified texture object. GlGenerateMipmap - opengl 4 reference pages., from https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenerateMipmap.xhtml 
// KhronosGroup, K. G. (2022, June 1). KhronosGroup/EGL-Registry: EGL API and extension registry., from https://github.com/KhronosGroup/EGL-Registry 
// Microsoft, M. (2022, June 1). Hint files. Microsoft Learn., from https://learn.microsoft.com/en-us/cpp/build/reference/hint-files?view=msvc-170 
// Microsoft, M. (2023, January 25). Warning pragma. Microsoft Learn., from https://learn.microsoft.com/en-us/cpp/preprocessor/warning?view=msvc-170 
// OpenGL, O. G. L. (2018, November 22). OpenGL type. OpenGL Type - OpenGL Wiki., from https://www.khronos.org/opengl/wiki/OpenGL_Type 
// Rodriguez, J. (2022, November 21). Docs.GL. glAttachShader - OpenGL 4., from https://docs.gl/gl4/glAttachShader#:~:text=glAttachShader%20attaches%20the%20shader%20object,will%20be%20performed%20on%20program%20. 
// SNHU, S. N. H. U. (2020, October 28). CS 330 module 6 assignment video. YouTube., from https://www.youtube.com/watch?v=TNUzCypFeWc&amp;ab_channel=SNHUMedia 
// SNHU, S. N. H. U. (2020, October 28). CS 330 module 6 milestone video. YouTube., from https://www.youtube.com/watch?v=kmdQ46mx2bw&amp;ab_channel=SNHUMedia 
// Standupdeskstore, S. (2022, July 1). Standupdeskstore. Standupdeskstore.com., from https://www.standupdeskstore.com/solid-wood-sit-stand-desk-top-walnut-72?campaignid=18061786689&amp
// WikiBooks, W.B. (2022, May 2).OpenGL programming / glstart / TUT3.Wikibooks, open books for an open world., from https ://en.wikibooks.org/wiki/OpenGL_Programming/GLStart/Tut3#:~:text=GL_LINE_LOOP,Draws%20triangles%20on%20screen 
// W3Schools, W. S. (2022, November 20). C++ Dereference. C++ Dereferencing., from https://www.w3schools.com/cpp/cpp_pointers_dereference.asp 

// image sources: 
//  Copyright-Only Dedication* (based on United States law) or Public Domain Certification - glasses case - Link: https://pxhere.com/en/photo/399103
//  CC0 1.0 Universal (CC0 1.0) Public Domain Dedication - table top wooden - Link: https://www.rawpixel.com/search/wood%20tabletop?page=1&sort=curated&topic_group=_topics
//  Copyright-Only Dedication* (based on United States law) or Public Domain Certification - lacrosse ball - Link: https://depositphotos.com/free-files/gradient.html
//  Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) - water bottle - Link: https://commons.wikimedia.org/wiki/File:Apply_Green_Patterns_to_your_Design_and_Feel_A_New_Look.jpg
//  Attribution 2.0 Generic (CC BY 2.0) - ipad case - Link: https://www.flickr.com/photos/x1brett/4662881043

// include file that has various properties for the shape including vertices and indices (Chapman, 2020, p. 1)
#include "ShapeGenerator.h"

// include file that has various properties for the shape including vertices and indices (Chapman, 2020, p. 1)
#include "ShapeData.h"

// include / header file that holds all OpenGL type declarations (Chapman, 2020, p. 1)
#include <glad/glad.h>

// include for GLFW that defines all constant, types, and function prototypes of the GLFW API (GLFW, 2018, p. 1)
#include <GLFW/glfw3.h>

// definition used to define the various images used within project (Chapman, 2020, p. 1)
#define STB_IMAGE_IMPLEMENTATION

// include file used to include textures within project (Chapman, 2020, p. 1)
#include "stb_image.h"

// header files that are used for the glm math functions (Chapman, 2020, p. 1)
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

// utilizes vector functions with vector library (Chapman, 2020, p. 1)
#include <vector>

// include files for the shader and camera classes utilized within project (Chapman, 2020, p. 1)
#include "shader.h"
#include "camera.h"

// standard input / output stream including cin, cout, cerr, etc to utilize in project (GeeksforGeeks, 2022, p. 1)
#include <iostream>

// include files for the cylinder class utilized within project (Chapman, 2020, p. 1)
#include "cylinder.h"

// boolean used to determine program is run from exe or from visual studio
bool runExe = false;

// spotlight color blue (Chapman, 2020, p. 1)
glm::vec3 gLightColor(0.0f, 0.0f, 1.0f);

// static variable used for drawing purposes
unsigned int STATIC_ONE_HUNDRED = 100;

// all user defined methods that initialize the program, various call back features, frame buffering, loading of texture (Chapman, 2020, p. 1)
void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void mouse_callback(GLFWwindow* window, double xpos, double ypos);
void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);
void processInput(GLFWwindow* window);
unsigned int loadTexture(const char* path);

// variables denoted for the window height and window width (Chapman, 2020, p. 1)
const unsigned int SCR_WIDTH = 800;
const unsigned int SCR_HEIGHT = 600;

// camera properties used to manipulate camera during project runtime (Chapman, 2020, p. 1)
Camera camera(glm::vec3(1.5f, 3.0f, 6.0f));
float lastX = SCR_WIDTH / 2.0f;
float lastY = SCR_HEIGHT / 2.0f;
bool firstMouse = true;

// boolean used to determine the perspective of the project for 2D and 3D capabilities (Chapman, 2020, p. 1)
bool perspective = true;

// variables used for timing purpose (Chapman, 2020, p. 1)
float deltaTime = 0.0f;
float lastFrame = 0.0f;

// various offset variables for the plane used within project (Chapman, 2020, p. 1)
const uint NUM_VERTICES_PER_TRI = 3;
const uint NUM_FLOATS_PER_VERTICE = 9;
const uint VERTEX_BYTE_SIZE = NUM_FLOATS_PER_VERTICE * sizeof(float);

// plane variables used to determine the plane indices, object ID, and the byte offset properties (Chapman, 2020, p. 1)
GLuint planeNumIndices;
GLuint planeVertexArrayObjectID;
GLuint planeIndexByteOffset;

// sphere variables used to determine the sphere indices, object ID, and the byte offset properties (Chapman, 2020, p. 1)
GLuint sphereNumIndices;
GLuint sphereVertexArrayObjectID;
GLuint sphereIndexByteOffset;

// variable to change the projection to perspective 3D (Chapman, 2020, p. 1)
glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);

/// <summary>
/// main that controls the entire flow of the project to render, create, and delete VAO and VBO within project (Chapman, 2020, p. 1)
/// </summary>
/// <returns></returns>
int main()
{
	// initializer function for GFLW, creates window and the OpenGL context, 
	// and initializes GLEW (loading function pointers) (Chapman, 2020, p .1)
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

	// if the following is defined (__Apple__), configure GLFW window to proper attributes (Chapman, 2020, p. 1) 
#ifdef __APPLE__
	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif

	// creation of the GLFW window given width, height, title (Chapman, 2020, p. 1)
	GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "7-1 Submit Project - Lawrence Arundel", NULL, NULL);
	if (window == NULL)
	{
		std::cout << "Failed to create GLFW window" << std::endl;
		glfwTerminate();
		return -1;
	}
	glfwMakeContextCurrent(window); // makes the context of the specified window current for the calling thread (GLFW, 2018, p. 1)
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // sets the maximum callback for the specified window (GLFW, 2018, p. 1)
	glfwSetCursorPosCallback(window, mouse_callback); // sets the cursor position to call back to console (Chapman, 2020, p. 1)
	glfwSetScrollCallback(window, scroll_callback);  // sets the scroll position to call back to console (Chapman, 2020, p. 1)

	// GFLW funciton to capture the position of the mouse (Chapman, 2020, p. 1)
	glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

	// load all OpenGL functions into project (Chapman, 2020, p. 1)
	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
	{
		std::cout << "Failed to initialize GLAD" << std::endl;
		return -1;
	}

	// enable / disable server-side GL capabilities (Graphics, 2006, p. 1)
	glEnable(GL_DEPTH_TEST);

	// files used to build our shaders to use within project (Chapman, 2020, p. 1)
	Shader lightingShader("shaderfiles/6.multiple_lights.vs", "shaderfiles/6.multiple_lights.fs");

	// various position of point lights used within project (Chapman, 2020, p. 1)
	glm::vec3 pointLightPositions[] = {
		glm::vec3(2.8f,  4.8f,  -1.2f),
		glm::vec3(1.8f,  4.8f,  -1.2f),
		glm::vec3(3.8f,  4.8f,  -1.2f),
		glm::vec3(4.8f,  4.8f,  -1.2f),
	};

	// *glasses case construction*

	// array used to construct the glasses case for the project
	// array used to distinguish between triangle vertices coordinates (x,y,z), normalized coordinates (x, y, z), and 
	// texture coordinates (x, y) for the shapes rendered (Chapman, 2020, p. 1)
	GLfloat verts[] = {
		// Bottom Face - right   Negative Y Normal   Texture Coordinates
		-0.5f, -0.5f, -0.5f,     0.0f, -1.0f, 0.0f,   0.0f, 1.0f,
		 0.5f, -0.5f, -0.5f,     0.0f, -1.0f, 0.0f,   1.0f, 1.0f,
		 0.5f, -0.5f,  0.5f,     0.0f, -1.0f, 0.0f,   1.0f, 0.0f,

		 // Bottom Face - left	 Negative Y Normal   Texture Coordinates
		  0.5f, -0.5f,  0.5f,    0.0f, -1.0f, 0.0f,   1.0f, 0.0f,
		 -0.5f, -0.5f,  0.5f,    0.0f, -1.0f, 0.0f,   0.0f, 0.0f,
		 -0.5f, -0.5f, -0.5f,    0.0f, -1.0f, 0.0f,   0.0f, 1.0f,

		 // Back face - left	Positive Z Normal	 Texture Coordinates
		 0.5f, -0.5f, -0.5f,    0.0f, 0.0f,  1.0f,	  1.0f, 1.0f,
		 0.5f,  0.0f,  0.0f,	0.0f, 0.0f,  1.0f,    0.0f, 1.0f,
		-0.5f,  0.0f,  0.0f,	0.0f, 0.0f,  1.0f,    1.0f, 0.0f,

		// Back face - right    Positive Z Normal	 Texture Coordinates
	   -0.5f,  0.0f,  0.0f,	    0.0f, 0.0f,  1.0f,    1.0f, 0.0f,
		0.5f, -0.5f, -0.5f,     0.0f, 0.0f,  1.0f,    1.0f, 1.0f,
	   -0.5f, -0.5f, -0.5f,     0.0f, 0.0f,  1.0f,    0.0f, 1.0f,

	   // Front face - left    Negative Z Normal	 Texture Coordinates
	 -0.5f,  0.0f,   0.0f,	    0.0f, 0.0f, -1.0f,    1.0f, 0.0f,
	  0.5f, -0.5f,   0.5f,     0.0f, 0.0f, -1.0f,	  1.0f, 1.0f,
	 -0.5f, -0.5f,   0.5f,	    0.0f, 0.0f, -1.0f,    0.0f, 1.0f,

	 // Front face - right	Negative Z Normal	 Texture Coordinates
  -0.5f,  0.0f,   0.0f,	    0.0f, 0.0f, -1.0f,    1.0f, 0.0f,
   0.5f, -0.5f,   0.5f,      0.0f, 0.0f, -1.0f,	  1.0f, 1.0f,
   0.5f,  0.0f,   0.0f,	    0.0f, 0.0f, -1.0f,    0.0f, 1.0f,

   // Side face, - right     Positive X Normal	 Texture Coordinates
   0.5f, -0.5f,   0.5f,      1.0f, 0.0f, 0.0f,	  1.0f, 0.0f,
   0.5f,  0.0f,   0.0f,	     1.0f, 0.0f, 0.0f,    1.0f, 1.0f,
   0.5f, -0.5f,  -0.5f,      1.0f, 0.0f, 0.0f,	  0.0f, 1.0f,

   // Side face - left       Negative X Normal	 Texture Coordinates
  -0.5f, -0.5f,   0.5f,      -1.0f, 0.0f, 0.0f,	  1.0f, 0.0f,
  -0.5f,  0.0f,   0.0f,	    -1.0f, 0.0f, 0.0f,    1.0f, 1.0f,
  -0.5f, -0.5f,  -0.5f,      -1.0f, 0.0f, 0.0f,	  0.0f, 1.0f,
	};

	// *start of construction of glasses VAO and VBO*

	// creation of the glasses VAO and VBO utilized within the project (Chapman, 2020, p. 1)
	unsigned int glassesVAO = 0, glassesVBO = 0;

	// creation of the coordinates for the vertices (x,y,z), normalized coordinates (x, y, z), and floats per UV (x, y_) repsectively (Chapman, 2020, p. 1)
	const GLuint floatsPerVertex = 3;
	const GLuint floatsPerNormal = 3;
	const GLuint floatsPerUV = 2;

	// generation of various vao used within the program / binding properties (Chapman, 2020, p. 1)
	glGenVertexArrays(1, &glassesVAO);
	glBindVertexArray(glassesVAO);

	// creation of VBO (Chapman, 2020, p. 1)
	glGenBuffers(1, &glassesVBO);
	glBindBuffer(GL_ARRAY_BUFFER, glassesVBO);
	glBufferData(GL_ARRAY_BUFFER, sizeof(verts), verts, GL_STATIC_DRAW);

	// number of bytes between vertices. if set to zero, then OpenGL assumes that vertex data is tightly packed (OpenGL, 2018, p. 1)
	GLint stride = sizeof(float) * (static_cast<unsigned long long>(floatsPerVertex + floatsPerNormal) + floatsPerUV);

	// vertex attribute pointers (Chapman, 2020, p. 1)
	glVertexAttribPointer(0, floatsPerVertex, GL_FLOAT, GL_FALSE, stride, 0);
	glEnableVertexAttribArray(0);

	// vertex attribute pointers (Chapman, 2020, p. 1)
	glVertexAttribPointer(1, floatsPerNormal, GL_FLOAT, GL_FALSE, stride, (char*)(sizeof(float) * floatsPerVertex));
	glEnableVertexAttribArray(1);

	// vertex attribute pointers (Chapman, 2020,p. 1)
	glVertexAttribPointer(2, floatsPerUV, GL_FLOAT, GL_FALSE, stride, (void*)(sizeof(float) * (static_cast<unsigned long long>(floatsPerVertex) + floatsPerNormal)));
	glEnableVertexAttribArray(2);

	// *start of creation of plane object*

	// creation of the plane object (Chapman, 2020, p. 1)
	ShapeData plane = ShapeGenerator::makePlane(10);

	// creation of the plane VAO and VBO utilized within the project (Chapman, 2020, p. 1)
	unsigned int planeVBO{}, planeVAO;
	glGenVertexArrays(1, &planeVAO);
	glGenBuffers(1, &planeVBO);

	// creation of VBO (Chapman, 2020, p. 1)
	glBindVertexArray(planeVAO);
	glBindBuffer(GL_ARRAY_BUFFER, planeVBO);
	glBufferData(GL_ARRAY_BUFFER, plane.vertexBufferSize() + plane.indexBufferSize(), 0, GL_STATIC_DRAW);

	// variable used to find the size of current offset for the plane object (Chapman, 2020, p. 1)
	GLsizeiptr currentOffset = 0;

	// redefines some or all of the data store for the buffer object currently bound to target (Khronos, 1999, p. 1)
	// set currentoffset plus equal to the plane object's buffer size (Chapman, 2020, p. 1)
	glBufferSubData(GL_ARRAY_BUFFER, currentOffset, plane.vertexBufferSize(), plane.vertices);
	currentOffset += plane.vertexBufferSize();

	// set the plane index byte offset equal to the current offset defined (Chapman, 2020, p. 1)
	planeIndexByteOffset = currentOffset;

	// redefines some or all of the data store for the buffer object currently bound to target (Khronos, 1999, p. 1)
	glBufferSubData(GL_ARRAY_BUFFER, currentOffset, plane.indexBufferSize(), plane.indices);

	// set plane number of indices equal to the object plane number of indices (Chapman, 2020, p. 1)
	planeNumIndices = plane.numIndices;

	// vertex attribute pointers (Chapman, 2020,p. 1)
	glEnableVertexAttribArray(0);
	glEnableVertexAttribArray(1);
	glEnableVertexAttribArray(2);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, VERTEX_BYTE_SIZE, (void*)0);
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, VERTEX_BYTE_SIZE, (void*)(sizeof(float) * 3));
	glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, VERTEX_BYTE_SIZE, (void*)(sizeof(float) * 6));
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, planeVBO);

	// *start to create sphere object*

	// creates the sphere object for project utilizing shape generator class (Chapman, 2020, p. 1)
	ShapeData sphere = ShapeGenerator::makeSphere();

	// creation of the plane VAO and VBO utilized within the project (Chapman, 2020, p. 1)
	unsigned int sphereVBO, sphereVAO;
	glGenVertexArrays(1, &sphereVAO);
	glGenBuffers(1, &sphereVBO);

	// creation of VBO (Chapman, 2020, p. 1)
	glBindVertexArray(sphereVAO);
	glBindBuffer(GL_ARRAY_BUFFER, sphereVBO);
	glBufferData(GL_ARRAY_BUFFER, sphere.vertexBufferSize() + sphere.indexBufferSize(), 0, GL_STATIC_DRAW);

	// variable used to find the size of current offset for the plane object (Chapman, 2020, p. 1)
	currentOffset = 0;

	// redefines some or all of the data store for the buffer object currently bound to target (Khronos, 1999, p. 1)
	// set currentoffset plus equal to the plane object's buffer size (Chapman, 2020, p. 1)
	glBufferSubData(GL_ARRAY_BUFFER, currentOffset, sphere.vertexBufferSize(), sphere.vertices);
	currentOffset += sphere.vertexBufferSize();

	// set the sphere index byte offset equal to the current offset defined (Chapman, 2020, p. 1)
	sphereIndexByteOffset = currentOffset;

	// redefines some or all of the data store for the buffer object currently bound to target (Khronos, 1999, p. 1)
	glBufferSubData(GL_ARRAY_BUFFER, currentOffset, sphere.indexBufferSize(), sphere.indices);

	// set sphere number of indices equal to the object sphere number of indices (Chapman, 2020, p. 1)
	sphereNumIndices = sphere.numIndices;

	// vertex attribute pointers (Chapman, 2020,p. 1)
	glEnableVertexAttribArray(0);
	glEnableVertexAttribArray(1);
	glEnableVertexAttribArray(2);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, VERTEX_BYTE_SIZE, (void*)0);
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, VERTEX_BYTE_SIZE, (void*)(sizeof(float) * 3));
	glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, VERTEX_BYTE_SIZE, (void*)(sizeof(float) * 6));
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sphereVBO);

	// * start of the iPad construction*
	GLfloat verts2[] = {
		// Vertex Coordinates Negative Z Normal  Texture Coordinates
		  -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f, 0.0f,
		   0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  1.0f, 0.0f,
		   0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  1.0f, 1.0f,
		   0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  1.0f, 1.0f,
		  -0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f, 1.0f,
		  -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f, 0.0f,

		  // Vertex Coordinates Positive Z Normal  Texture Coordinates
		   -0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  0.0f, 0.0f,
			0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  1.0f, 0.0f,
			0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  1.0f, 1.0f,
			0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  1.0f, 1.0f,
		   -0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  0.0f, 1.0f,
		   -0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  0.0f, 0.0f,

		   // Vertex Coordinates Negative X Normal  Texture Coordinates
		   -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,  1.0f, 0.0f,
		   -0.5f,  0.5f, -0.5f, -1.0f,  0.0f,  0.0f,  1.0f, 1.0f,
		   -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,  0.0f, 1.0f,
		   -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,  0.0f, 1.0f,
		   -0.5f, -0.5f,  0.5f, -1.0f,  0.0f,  0.0f,  0.0f, 0.0f,
		   -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,  1.0f, 0.0f,

		   // Vertex Coordinates Positive X Normal  Texture Coordinates
		   0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,  1.0f, 0.0f,
		   0.5f,  0.5f, -0.5f,  1.0f,  0.0f,  0.0f,  1.0f, 1.0f,
		   0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,  0.0f, 1.0f,
		   0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,  0.0f, 1.0f,
		   0.5f, -0.5f,  0.5f,  1.0f,  0.0f,  0.0f,  0.0f, 0.0f,
		   0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,  1.0f, 0.0f,

		   // Vertex Coordinates Negative Y Normal  Texture Coordinates
		  -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,  0.0f, 1.0f,
		   0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,  1.0f, 1.0f,
		   0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,  1.0f, 0.0f,
		   0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,  1.0f, 0.0f,
		  -0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,  0.0f, 0.0f,
		  -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,  0.0f, 1.0f,

		  // Vertex Coordinates Positive Y Normal  Texture Coordinates
		 -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,  0.0f, 1.0f,
		  0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,  1.0f, 1.0f,
		  0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,  1.0f, 0.0f,
		  0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,  1.0f, 0.0f,
		 -0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,  0.0f, 0.0f,
		 -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,  0.0f, 1.0f
	};

	// creation of the cube VAO and VBO utilized within the project (Chapman, 2020, p. 1)
	unsigned int cubeVAO = 0, cubeVBO = 0;

	// creation of the coordinates for the vertices and points for vertices (x,y,z), normalized coordinates (x, y, z), and floats per UV (x, y_) repsectively (Chapman, 2020, p. 1)
	const GLuint floatsPerVertex2 = 3;
	const GLuint floatsPerNormal2 = 3;
	const GLuint floatsPerUV2 = 2;

	// generation of various vao used within the program / binding properties (Chapman, 2020, p. 1)
	glGenVertexArrays(1, &cubeVAO);
	glBindVertexArray(cubeVAO);

	// creation of VBO (Chapman, 2020, p. 1)
	glGenBuffers(1, &cubeVBO);
	glBindBuffer(GL_ARRAY_BUFFER, cubeVBO);
	glBufferData(GL_ARRAY_BUFFER, sizeof(verts2), verts2, GL_STATIC_DRAW);

	// number of bytes between vertices. if set to zero, then OpenGL assumes that vertex data is tightly packed (OpenGL, 2018, p. 1)
	GLint stride2 = sizeof(float) * (static_cast<unsigned long long>(floatsPerVertex2 + floatsPerNormal2) + floatsPerUV2);

	// vertex attribute pointers (Chapman, 2020, p. 1)
	glVertexAttribPointer(0, floatsPerVertex2, GL_FLOAT, GL_FALSE, stride2, 0);
	glEnableVertexAttribArray(0);

	// vertex attribute pointers (Chapman, 2020, p. 1)
	glVertexAttribPointer(1, floatsPerNormal2, GL_FLOAT, GL_FALSE, stride2, (char*)(sizeof(float) * floatsPerVertex2));
	glEnableVertexAttribArray(1);

	// vertex attribute pointers (Chapman, 2020,p. 1)
	glVertexAttribPointer(2, floatsPerUV2, GL_FLOAT, GL_FALSE, stride2, (void*)(sizeof(float) * (static_cast<unsigned long long>(floatsPerVertex2) + floatsPerNormal2)));
	glEnableVertexAttribArray(2);

	// load the various textures used within the project (Chapman, 2020, p. 1)
	unsigned int planeDiffuseMap = loadTexture("../7-1 Submit Project/table_top.jpg");
	unsigned int glassesDiffuseMap = loadTexture("../7-1 Submit Project/exterior_case.jpg");
	unsigned int sphereDiffuseMap = loadTexture("../7-1 Submit Project/sphere.jpg");
	unsigned int cylinderDiffuseMap = loadTexture("../7-1 Submit Project/cylinder.jpg");
	unsigned int topCylinderDiffuseMap = loadTexture("../7-1 Submit Project/cylinder.jpg");
	unsigned int cubeDiffuseMap = loadTexture("../7-1 Submit Project/ipad_case.jpg");

	// if the project is funning the exe, then set the variables used to load textures equal to paths below (Chapman, 2020, p. 1)
	if (!runExe) {
		planeDiffuseMap = loadTexture("../../7-1 Submit Project/Debug/table_top.jpg");
		glassesDiffuseMap = loadTexture("../../7-1 Submit Project/Debug/exterior_case.jpg");
		sphereDiffuseMap = loadTexture("../../7-1 Submit Project/Debug/sphere.jpg");
		cylinderDiffuseMap = loadTexture("../../7-1 Submit Project/Debug/cylinder.jpg");
		topCylinderDiffuseMap = loadTexture("../../7-1 Submit Project/Debug/cylinder.jpg");
		cubeDiffuseMap = loadTexture("../../7-1 Submit Project/Debug/ipad_case.jpg");
	}

	// set variables material equal to the shader to be used for light properties (Chapman, 2020, p. 1)
	lightingShader.use();
	lightingShader.setInt("material.diffuse", 0);
	lightingShader.setInt("material.specular", 1);

	// draws every frame of the application (render loop) so the frequency with which it is called dictates the 
	// frame rate (Chapman, 2020, p. 1)
	while (!glfwWindowShouldClose(window))
	{
		// timing that is used to calculate the fps during the operation of program (Chapman, 2020, p. 1)
		float currentFrame = static_cast<float>(glfwGetTime());
		deltaTime = currentFrame - lastFrame;
		lastFrame = currentFrame;

		// validates / processes user input when window is resized accordingly (Chapman, 2020, p. 1)
		processInput(window);

		// clears background of the window and sets the background color to default black / clear z buffer (Chapman, 2020, p. 1)
		glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		// use the lighting shader and set the vec3 and float equal to the view position / camera, and the material's shininess variable (Chapman, 2020, p. 1)
		lightingShader.use();
		lightingShader.setVec3("viewPos", camera.Position);
		lightingShader.setFloat("material.shininess", 32.0f);

		// setting up of the directional lights (Chapman, 2020, p. 1)
		lightingShader.setVec3("dirLight.direction", 2.5f, 2.0f, 0.0f);
		lightingShader.setVec3("dirLight.ambient", 0.05f, 0.05f, 0.05f);
		lightingShader.setVec3("dirLight.diffuse", 0.4f, 0.4f, 0.4f);
		lightingShader.setVec3("dirLight.specular", 0.5f, 0.5f, 0.5f);
		lightingShader.setVec3("dirLight.lightColor", 1.0f, 0.0f, 1.0f);

		// setting up of the key lights (Chapman, 2020, p. 1)
		lightingShader.setVec3("pointLights[0].position", pointLightPositions[0]);
		lightingShader.setVec3("pointLights[0].ambient", 0.5f, 0.5f, 0.5f);
		lightingShader.setVec3("pointLights[0].diffuse", 0.5f, 0.5f, 0.5f);
		lightingShader.setVec3("pointLights[0].specular", 1.0f, 1.0f, 1.0f);
		lightingShader.setVec3("pointLights[0].lightColor", 0.0f, 0.0f, 1.0f);
		lightingShader.setFloat("pointLights[0].constant", 1.0f);
		lightingShader.setFloat("pointLights[0].linear", static_cast <float>(0.09));
		lightingShader.setFloat("pointLights[0].quadratic", static_cast <float>(0.032));

		// setting up of the fill lights (Chapman, 2020, p. 1)
		lightingShader.setVec3("pointLights[1].position", pointLightPositions[1]);
		lightingShader.setVec3("pointLights[1].ambient", 2.0f, 2.0f, 2.0f);
		lightingShader.setVec3("pointLights[1].diffuse", 1.1f, 1.1f, 1.1f);
		lightingShader.setVec3("pointLights[1].specular", 1.0f, 1.0f, 1.0f);
		lightingShader.setVec3("pointLights[1].lightColor", 1.0f, 1.0f, 1.0f);
		lightingShader.setFloat("pointLights[1].constant", 1.0f);
		lightingShader.setFloat("pointLights[1].linear", static_cast <float>(0.09));
		lightingShader.setFloat("pointLights[1].quadratic", static_cast <float>(0.032));

		// setting up of the point light 3 (Chapman, 2020, p. 1)
		lightingShader.setVec3("pointLights[2].position", pointLightPositions[2]);
		lightingShader.setVec3("pointLights[2].ambient", 0.05f, 0.05f, 0.05f);
		lightingShader.setVec3("pointLights[2].diffuse", 0.8f, 0.8f, 0.8f);
		lightingShader.setVec3("pointLights[2].specular", 1.0f, 1.0f, 1.0f);
		lightingShader.setVec3("pointLights[2].lightColor", 1.0f, 1.0f, 1.0f);
		lightingShader.setFloat("pointLights[2].constant", 1.0f);
		lightingShader.setFloat("pointLights[2].linear", static_cast <float>(0.09));
		lightingShader.setFloat("pointLights[2].quadratic", static_cast <float>(0.032));

		// setting up of the point light 4 (Chapman, 2020, p. 1)
		lightingShader.setVec3("pointLights[3].position", pointLightPositions[3]);
		lightingShader.setVec3("pointLights[3].ambient", 0.05f, 0.05f, 0.05f);
		lightingShader.setVec3("pointLights[3].diffuse", 0.8f, 0.8f, 0.8f);
		lightingShader.setVec3("pointLights[3].specular", 1.0f, 1.0f, 1.0f);
		lightingShader.setVec3("pointLights[3].lightColor", 1.0f, 1.0f, 1.0f);
		lightingShader.setFloat("pointLights[3].constant", 1.0f);
		lightingShader.setFloat("pointLights[3].linear", static_cast <float>(0.09));
		lightingShader.setFloat("pointLights[3].quadratic", static_cast <float>(0.032));

		// setting up of the spotlight (Chapman, 2020, p. 1)
		lightingShader.setVec3("spotLight.position", camera.Position);
		lightingShader.setVec3("spotLight.direction", camera.Front);
		lightingShader.setVec3("spotLight.ambient", 1.0f, 1.0f, 1.0f);
		lightingShader.setVec3("spotLight.diffuse", 3.7f, 3.7f, 3.7f);
		lightingShader.setVec3("spotLight.specular", 1.0f, 1.0f, 1.0f);
		lightingShader.setVec3("spotLight.lightColor", 0.0f, 0.0f, 1.0f);
		lightingShader.setFloat("spotLight.constant", 1.0f);
		lightingShader.setFloat("spotLight.linear", static_cast <float>(0.09));
		lightingShader.setFloat("spotLight.quadratic", static_cast <float>(0.032));
		lightingShader.setFloat("spotLight.cutOff", glm::cos(glm::radians(12.5f)));
		lightingShader.setFloat("spotLight.outerCutOff", glm::cos(glm::radians(15.0f)));

		// obtained the camera view transformation matrix (Chapman, 2020, p. 1)
		glm::mat4 view = camera.GetViewMatrix();

		// shader used to set the mat4 with the view and projection uniform ID (Chapman, 2020, p. 1)
		lightingShader.setMat4("projection", projection);
		lightingShader.setMat4("view", view);

		// model matrix which is used for calculation purposes / world transformation (Chapman, 2020, p. 1)
		glm::mat4 planeModel = glm::mat4(1.0f);
		glm::mat4 glassesModel = glm::mat4(1.0f);
		glm::mat4 sphereModel = glm::mat4(1.0f);
		glm::mat4 cylinderModel = glm::mat4(1.0f);
		glm::mat4 topCylinderModel = glm::mat4(1.0f);
		glm::mat4 cubeModel = glm::mat4(1.0f);

		// bind textures on corresponding texture units - plane object (Chapman, 2020, p. 1)
		glBindTexture(GL_TEXTURE_2D, planeDiffuseMap);
		glBindVertexArray(planeVAO);
		planeModel = glm::translate(planeModel, glm::vec3(2.5f, -0.45f, 0.0f)) * glm::scale(planeModel, glm::vec3(2.0f, 1.0f, 1.0f));
		lightingShader.setMat4("model", planeModel);

		// function used to draw the element of the plane given the correct properties (Chapman, 2020, p. 1)
		glDrawElements(GL_TRIANGLES, planeNumIndices, GL_UNSIGNED_SHORT, (void*)planeIndexByteOffset);

		// bind textures on corresponding texture units - glasses obejct (Chapman, 2020, p. 1)
		glBindTexture(GL_TEXTURE_2D, glassesDiffuseMap);
		glBindVertexArray(glassesVAO);
		glassesModel = glm::translate(glassesModel, glm::vec3(1.75f, 0.60f, 2.75f));
		glassesModel = glm::scale(glassesModel, glm::vec3(3.0f, 2.0f, 1.0f));
		lightingShader.setMat4("model", glassesModel);

		// function used to draw the element of the glasses case given the correct properties (Chapman, 2020, p. 1)
		glDrawArrays(GL_TRIANGLES, 0, STATIC_ONE_HUNDRED);

		// process that begins the set up process for drawing the sphere given the properties and matrix information (Chapman, 2020, p. 1)
		glBindTexture(GL_TEXTURE_2D, sphereDiffuseMap);
		glBindVertexArray(sphereVAO);
		sphereModel = glm::translate(sphereModel, glm::vec3(7.5f, 0.1f, 2.5f));
		sphereModel = glm::scale(sphereModel, glm::vec3(0.5f));
		lightingShader.setMat4("model", sphereModel);

		// function that draws the sphere given the indices and index byte offset (Chapman, 2020, p. 1)
		glDrawElements(GL_TRIANGLES, sphereNumIndices, GL_UNSIGNED_SHORT, (void*)sphereIndexByteOffset);

		// bind textures on corresponding texture units - cube obejct (Chapman, 2020, p. 1)
		glBindTexture(GL_TEXTURE_2D, cubeDiffuseMap);
		glBindVertexArray(cubeVAO);
		cubeModel = glm::translate(cubeModel, glm::vec3(-4.5f, -0.3f, -1.2f));
		cubeModel = glm::scale(cubeModel, glm::vec3(3.25f, 0.1f, 4.5f));
		lightingShader.setMat4("model", cubeModel);

		// function used to draw the element of the cube given the correct properties (Chapman, 2020, p. 1)
		glDrawArrays(GL_TRIANGLES, 0, STATIC_ONE_HUNDRED);

		// process that begins the set up process for drawing the cylinder given the properties and matrix information (Chapman, 2020, p. 1)
		glBindTexture(GL_TEXTURE_2D, cylinderDiffuseMap);
		cylinderModel = glm::translate(cylinderModel, glm::vec3(5.5f, 1.08f, -2.5f));
		cylinderModel = glm::scale(cylinderModel, glm::vec3(0.5f, 3.0f, 0.5f));
		lightingShader.setMat4("model", cylinderModel);

		// creation of the cylinder object, and then the rendering of the object of that class Cylinder (Chapman, 2020, p. 1)
		static_meshes_3D::Cylinder C(2, 10, 1, true, true, true);
		C.render();

		// process that begins the set up process for drawing the cylinder given the properties and matrix information (Chapman, 2020, p. 1)
		glBindTexture(GL_TEXTURE_2D, topCylinderDiffuseMap);
		topCylinderModel = glm::translate(topCylinderModel, glm::vec3(5.5f, 2.9f, -2.5f));
		topCylinderModel = glm::scale(topCylinderModel, glm::vec3(0.2f, 0.7f, 0.2f));
		lightingShader.setMat4("model", topCylinderModel);

		// creation of the cylinder object, and then the rendering of the object of that class Cylinder (Chapman, 2020, p. 1)
		static_meshes_3D::Cylinder Ctop(2, 10, 1, true, true, true);
		Ctop.render();

		// swaps the front and back buffers of the specified window (GLFW, 2018, p. 1)
		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	//  deletes the plane VAO and VBO (Chapman, 2020, p. 1)
	glDeleteVertexArrays(1, &planeVAO);
	glDeleteBuffers(1, &planeVBO);

	//  deletes the glasses case VAO and VBO (Chapman, 2020, p. 1)
	glDeleteVertexArrays(1, &glassesVAO);
	glDeleteBuffers(1, &glassesVBO);

	//  deletes the ipad / cube VAO and VBO (Chapman, 2020, p. 1)
	glDeleteVertexArrays(1, &cubeVAO);
	glDeleteBuffers(1, &cubeVBO);

	// terminates the project and all GLFW resources (Chapman, 2020, p. 1)
	glfwTerminate();
	return 0;
}

/// <summary>
/// validates / processes user input when window is resized accordingly (Chapman, 2020, p. 1)
/// </summary>
/// <param name="window"></param>
void processInput(GLFWwindow* window)
{
	// variable used to calculate the camera speed for project (Chapman, 2020, p. 1)
	float cameraOffset = camera.MovementSpeed * deltaTime;

	// condition that states if the escape key while window is open equates as user pressing
	// then the window's state should be set from false to true as true being window close (Chapman, 2020, p. 1) ; (GLFW, 2018, p. 1)
	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
		glfwSetWindowShouldClose(window, true);

	// condition that states if the w key is pressed, then process that input by moving forward on screen (Chapman, 2020, p. 1)
	if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
		camera.ProcessKeyboard(FORWARD, deltaTime);

	// condition that states if the s key is pressed, then process that input by moving backward on screen (Chapman, 2020, p. 1)
	if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
		camera.ProcessKeyboard(BACKWARD, deltaTime);

	// condition that states if the a key is pressed, then process that input by moving left on screen (Chapman, 2020, p. 1)
	if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
		camera.ProcessKeyboard(LEFT, deltaTime);

	// condition that states if the d key is pressed, then process that input by moving right on screen (Chapman, 2020, p. 1)
	if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
		camera.ProcessKeyboard(RIGHT, deltaTime);

	// condition that states if the q key is pressed, then process that input by moving up on screen (Chapman, 2020, p. 1)
	if (glfwGetKey(window, GLFW_KEY_Q) == GLFW_PRESS)
		camera.Position += cameraOffset * camera.Up;

	// condition that states if the e key is pressed, then process that input by moving down on screen (Chapman, 2020, p. 1)
	if (glfwGetKey(window, GLFW_KEY_E) == GLFW_PRESS)
		camera.Position -= cameraOffset * camera.Up;

	// condition that states if the p key is pressed, then process that input by changing perspective (to orthographic 2D) of camera (Chapman, 2020, p. 1)
	if (glfwGetKey(window, GLFW_KEY_P) == GLFW_PRESS) {
		if (perspective) {
			projection = glm::ortho(-5.0f, 5.0f, -5.0f, 5.0f, 0.1f, 100.0f);
			perspective = false;
		}

		// condition that states if the p key is pressed and change perspective is false, then change the perspective back to the perspective projection of camera (Chapman, 2020, p. 1)
		else {
			projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);
			perspective = true;
		}
	}

}

/// <summary>
/// specifies the affine transformation of x and y from normalized device coordinates
/// to window coordinates (Graphics, 2006, p. 1)
/// </summary>
/// <param name="window"></param>
/// <param name="width"></param>
/// <param name="height"></param>
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
	glViewport(0, 0, width, height);
}

/// <summary>
/// function that obtains the position of the mouse and calls it back to console (Chapman, 2020, p. 1)
/// </summary>
/// <param name="window"></param>
/// <param name="xpos"></param>
/// <param name="ypos"></param>
void mouse_callback(GLFWwindow* window, double xpos, double ypos)
{
	// condition states if the mouse is moving, set the last coordinate of x and y to the position and set the mouse attribute to false (Chapman, 2020, p. 1)
	if (firstMouse)
	{
		lastX = static_cast <float>(xpos);
		lastY = static_cast <float>(ypos);
		firstMouse = false;
	}

	// variables set current coordinates of camera depending on mouse movement (Chapman, 2020, p. 1)
	float xoffset = static_cast<float>(xpos - lastX);
	float yoffset = static_cast<float>(lastY - ypos);

	// variables set the position of the x and y coordinates of the previous movement (Chapman, 2020, p. 1)
	lastX = static_cast <float>(xpos);
	lastY = static_cast <float>(ypos);

	// processing of the mouse movement given the required parameters to function accordingly (Chapman, 2020, p. 1)
	camera.ProcessMouseMovement(xoffset, yoffset);
}

/// <summary>
/// function that is operated when the mousescroll is functioned (Chapman, 2020, p. 1)
/// </summary>
/// <param name="window"></param>
/// <param name="xoffset"></param>
/// <param name="yoffset"></param>
void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
{
	// set gcamera movespeed to the yoffset, depending on mouse scroll up or down (scroll up increase or scroll down decrease)
	// if the movespeed is less than 1, then set it equal to 1 as a constraint
	// if the movespeed is greater than 45, then set it equal to 45 as a constraint (Chapman, 2020, p. 1)
	camera.MovementSpeed += (float)yoffset;
	if (camera.MovementSpeed < 1.0f)
		camera.MovementSpeed = 1.0f;
	if (camera.MovementSpeed > 45.0f)
		camera.MovementSpeed = 45.0f;
}

/// <summary>
/// function used to load proper texture given the texture path (Chapman, 2020, p. 1)
/// </summary>
/// <param name="path"></param>
/// <returns></returns>
unsigned int loadTexture(char const* path)
{
	// variables used to assign texture ID to proper integer value (Chapman, 2020, p. 1)
	unsigned int textureID;
	glGenTextures(1, &textureID);

	// variable used to define the width, height, and number of components from texture image (Chapman, 2020, p. 1)
	int width, height, nrComponents;

	// method that flips the image vertically (Chapman, 2020, p. 1)
	stbi_set_flip_vertically_on_load(true);

	// variables used to specify the width, heigh, channel, and loading of image for project (Chapman, 2020, p. 1)
	unsigned char* data = stbi_load(path, &width, &height, &nrComponents, 0);

	// if data is present, create structure format (Chapman, 2020, p. 1)
	if (data)
	{
		// used to denote the format of the properties for the image (Chapman, 2020, p. 1)
		GLenum format{};

		// if the number of components equals 1, set format equal to GL_RED. else if number components equals 3, set format equal 
		// to GL_RGB, else if number of components equals 4, set format equal to GL_RGBA (Chapman, 2020, p. 1)
		if (nrComponents == 1)
			format = GL_RED;
		else if (nrComponents == 3)
			format = GL_RGB;
		else if (nrComponents == 4)
			format = GL_RGBA;

		// gen / bind texture variables (Chapman, 2020, p. 1)
		// generates mipmaps for the texture attached to target of the active texture unit (Khronos, 1999, p. 1)
		glBindTexture(GL_TEXTURE_2D, textureID);
		glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);
		glGenerateMipmap(GL_TEXTURE_2D);

		// filtering parameters for the texture (Chapman, 2020, p. 1)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR_MIPMAP_LINEAR);

		// unbinds the texture for the 2D image, and release memeory dynamically (Chapman, 2020, p. 1)
		// set runExe equal to true whether running in console or exe file in project directory (Chapman, 2020, p. 1)
		stbi_image_free(data);
		runExe = true;
	}
	else
	{
		// unbinds the texture for the 2D image, and release memeory dynamically (Chapman, 2020, p. 1)
		// set runExe equal to true whether running in console or exe file in project directory (Chapman, 2020, p. 1)
		stbi_image_free(data);
		runExe = false;
	}

	// return integer for texture ID (Chapman, 2020, p. 1)
	return textureID;
}
